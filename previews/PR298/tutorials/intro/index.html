<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Basic usage · Optimization.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://Optimization.sciml.ai/stable/tutorials/intro/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Optimization.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Optimization.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Optimization.jl: A Unified Optimization Package</a></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>Basic usage</a><ul class="internal"><li><a class="tocitem" href="#Controlling-Gradient-Calculations-(Automatic-Differentiation)"><span>Controlling Gradient Calculations (Automatic Differentiation)</span></a></li><li><a class="tocitem" href="#Setting-Box-Constraints"><span>Setting Box Constraints</span></a></li></ul></li><li><a class="tocitem" href="../rosenbrock/">Solving the Rosenbrock Problem in &gt;10 Ways</a></li><li><a class="tocitem" href="../minibatch/">Data Iterators and Minibatching</a></li><li><a class="tocitem" href="../symbolic/">Symbolic Problem Building with ModelingToolkit</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../../API/optimization_problem/">Defining OptimizationProblems</a></li><li><a class="tocitem" href="../../API/optimization_function/">OptimizationFunction</a></li><li><a class="tocitem" href="../../API/solve/">Common Solver Options (Solve Keyword Arguments)</a></li><li><a class="tocitem" href="../../API/modelingtoolkit/">ModelingToolkit Integration</a></li></ul></li><li><span class="tocitem">Optimizer Packages</span><ul><li><a class="tocitem" href="../../optimization_packages/blackboxoptim/">BlackBoxOptim.jl</a></li><li><a class="tocitem" href="../../optimization_packages/cmaevolutionstrategy/">CMAEvolutionStrategy.jl</a></li><li><a class="tocitem" href="../../optimization_packages/evolutionary/">Evolutionary.jl</a></li><li><a class="tocitem" href="../../optimization_packages/flux/">Flux.jl</a></li><li><a class="tocitem" href="../../optimization_packages/gcmaes/">GCMAES.jl</a></li><li><a class="tocitem" href="../../optimization_packages/mathoptinterface/">MathOptInterface.jl</a></li><li><a class="tocitem" href="../../optimization_packages/multistartoptimization/">MultistartOptimization.jl</a></li><li><a class="tocitem" href="../../optimization_packages/metaheuristics/">Metaheuristics.jl</a></li><li><a class="tocitem" href="../../optimization_packages/nomad/">NOMAD.jl</a></li><li><a class="tocitem" href="../../optimization_packages/nlopt/">NLopt.jl</a></li><li><a class="tocitem" href="../../optimization_packages/nonconvex/">Nonconvex.jl</a></li><li><a class="tocitem" href="../../optimization_packages/optim/">Optim.jl</a></li><li><a class="tocitem" href="../../optimization_packages/quaddirect/">QuadDIRECT.jl</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Basic usage</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Basic usage</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/Optimization.jl/blob/master/docs/src/tutorials/intro.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Basic-usage"><a class="docs-heading-anchor" href="#Basic-usage">Basic usage</a><a id="Basic-usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-usage" title="Permalink"></a></h1><p>In this tutorial we introduce the basics of Optimization.jl by showing how to easily mix local optimizers from Optim.jl and global optimizers from BlackBoxOptim.jl on the Rosenbrock equation. The simplest copy-pasteable code to get started is the following:</p><pre><code class="language-julia hljs"># Import the package and define the problem to optimize
using Optimization
rosenbrock(u,p) =  (u[1] - u[1])^2 + p[2] * (u[2] - u[1]^2)^2
u0 = zeros(2)
p  = [1.0,100.0]

prob = OptimizationProblem(rosenbrock,u0,p)

# Import a solver package and solve the optimization problem
using OptimizationOptimJL
sol = solve(prob,NelderMead())

# Import a different solver package and solve the optimization problem a different way
using OptimizationBBO
prob = OptimizationProblem(rosenbrock, u0, p, lb = [-1.0,-1.0], ub = [1.0,1.0])
sol = solve(prob,BBO_adaptive_de_rand_1_bin_radiuslimited())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">u: 2-element Vector{Float64}:
 0.2947487476261281
 0.08687682418407779</code></pre><p>Notice that Optimization.jl is the core glue package that holds all of the common pieces, but to solve the equations we need to use a solver package. Here, OptimizationOptimJL is for <a href="https://github.com/JuliaNLSolvers/Optim.jl">Optim.jl</a> and OptimizationBBO is for <a href="https://github.com/robertfeldt/BlackBoxOptim.jl">BlackBoxOptim.jl</a>.</p><p>The output of the first optimization task (with the <code>NelderMead()</code> algorithm) is given below:</p><pre><code class="language- hljs">sol = solve(prob,NelderMead())</code></pre><p>The solution from the original solver can always be obtained via <code>original</code>:</p><pre><code class="language-julia hljs">sol.original</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BlackBoxOptim.OptimizationResults(&quot;adaptive_de_rand_1_bin_radiuslimited&quot;, &quot;Max number of steps (10000) reached&quot;, 10001, 1.655725345752457e9, 0.18924617767333984, BlackBoxOptim.ParamsDictChain[BlackBoxOptim.ParamsDictChain[Dict{Symbol, Any}(:CallbackInterval =&gt; 0.0, :RngSeed =&gt; 958279, :SearchRange =&gt; [(-1.0, 1.0), (-1.0, 1.0)], :Method =&gt; :adaptive_de_rand_1_bin_radiuslimited, :CallbackFunction =&gt; OptimizationBBO.var&quot;#_cb#23&quot;{OptimizationBBO.var&quot;#21#25&quot;, Base.Iterators.Cycle{Tuple{Optimization.NullData}}}(OptimizationBBO.var&quot;#21#25&quot;(), Base.Iterators.Cycle{Tuple{Optimization.NullData}}((Optimization.NullData(),)), Core.Box(8.239441791244058e-13), Core.Box(Optimization.NullData()), Core.Box(2)), :MaxSteps =&gt; 10000),Dict{Symbol, Any}()],Dict{Symbol, Any}(:CallbackInterval =&gt; -1.0, :TargetFitness =&gt; nothing, :TraceMode =&gt; :compact, :FitnessScheme =&gt; BlackBoxOptim.ScalarFitnessScheme{true}(), :MinDeltaFitnessTolerance =&gt; 1.0e-50, :NumDimensions =&gt; :NotSpecified, :FitnessTolerance =&gt; 1.0e-8, :TraceInterval =&gt; 0.5, :MaxStepsWithoutProgress =&gt; 10000, :MaxSteps =&gt; 10000…)], 10115, BlackBoxOptim.ScalarFitnessScheme{true}(), BlackBoxOptim.TopListArchiveOutput{Float64, Vector{Float64}}(1.8570223177112138e-19, [0.2947487476261281, 0.08687682418407779]), BlackBoxOptim.PopulationOptimizerOutput{BlackBoxOptim.FitPopulation{Float64}}(BlackBoxOptim.FitPopulation{Float64}([0.2945595407147436 0.2945556776962536 … 0.29411209485980394 0.29447314435498634; 0.08676532260354594 0.08676304719479673 … 0.08650192532642864 0.08671443735559521], NaN, [1.7853562102761387e-17, 4.665233749377799e-19, 2.665901263980293e-16, 2.587025146245483e-16, 9.746444103992938e-16, 1.8677159916710568e-16, 2.774668833025315e-17, 4.822210936443709e-17, 6.654964635264454e-19, 3.8535794700637664e-16  …  8.896405266500356e-18, 5.53699933751517e-17, 1.20491509742781e-15, 6.602263362456505e-18, 1.0646390613844618e-14, 6.129501920742549e-16, 2.0024600012082877e-16, 1.5859765812962152e-15, 9.674814227827418e-17, 2.1245486035887957e-15], 0, BlackBoxOptim.Candidate{Float64}[BlackBoxOptim.Candidate{Float64}([0.29411209485980394, 0.08650192532642864], 49, 9.674814227827418e-17, BlackBoxOptim.AdaptiveDiffEvoRandBin{3}(BlackBoxOptim.AdaptiveDiffEvoParameters(BlackBoxOptim.BimodalCauchy(Distributions.Cauchy{Float64}(μ=0.65, σ=0.1), Distributions.Cauchy{Float64}(μ=1.0, σ=0.1), 0.5, false, true), BlackBoxOptim.BimodalCauchy(Distributions.Cauchy{Float64}(μ=0.1, σ=0.1), Distributions.Cauchy{Float64}(μ=0.95, σ=0.1), 0.5, false, true), [0.7007301747965136, 0.9959478195965664, 1.0, 0.9247230444007024, 1.0, 0.677131354916191, 0.8044203818289851, 0.5087321809190872, 0.9447696673507726, 0.5587582733147343  …  0.9758387494148241, 1.0, 0.623055851692415, 0.7424230454737598, 0.6458436121112805, 1.0, 0.41295899643635925, 1.0, 0.796799054374631, 0.9351854918885848], [0.07300594033118933, 1.0, 0.5692990084393189, 0.10320144738210445, 0.0015184357609279026, 1.0, 0.2182643306631987, 0.14831768714895435, 0.8605494483552683, 0.15121185280554725  …  0.13378948759528417, 1.0, 0.9180640677523777, 0.08679600538539733, 1.0, 0.1750263074238677, 0.5958205439920421, 1.0, 0.18762033163132724, 1.0])), 0), BlackBoxOptim.Candidate{Float64}([0.2942441109297117, 0.0865795060454455], 49, 8.239441791244058e-13, BlackBoxOptim.AdaptiveDiffEvoRandBin{3}(BlackBoxOptim.AdaptiveDiffEvoParameters(BlackBoxOptim.BimodalCauchy(Distributions.Cauchy{Float64}(μ=0.65, σ=0.1), Distributions.Cauchy{Float64}(μ=1.0, σ=0.1), 0.5, false, true), BlackBoxOptim.BimodalCauchy(Distributions.Cauchy{Float64}(μ=0.1, σ=0.1), Distributions.Cauchy{Float64}(μ=0.95, σ=0.1), 0.5, false, true), [0.7007301747965136, 0.9959478195965664, 1.0, 0.9247230444007024, 1.0, 0.677131354916191, 0.8044203818289851, 0.5087321809190872, 0.9447696673507726, 0.5587582733147343  …  0.9758387494148241, 1.0, 0.623055851692415, 0.7424230454737598, 0.6458436121112805, 1.0, 0.41295899643635925, 1.0, 0.796799054374631, 0.9351854918885848], [0.07300594033118933, 1.0, 0.5692990084393189, 0.10320144738210445, 0.0015184357609279026, 1.0, 0.2182643306631987, 0.14831768714895435, 0.8605494483552683, 0.15121185280554725  …  0.13378948759528417, 1.0, 0.9180640677523777, 0.08679600538539733, 1.0, 0.1750263074238677, 0.5958205439920421, 1.0, 0.18762033163132724, 1.0])), 0)], Base.Threads.SpinLock(0))))</code></pre><h2 id="Controlling-Gradient-Calculations-(Automatic-Differentiation)"><a class="docs-heading-anchor" href="#Controlling-Gradient-Calculations-(Automatic-Differentiation)">Controlling Gradient Calculations (Automatic Differentiation)</a><a id="Controlling-Gradient-Calculations-(Automatic-Differentiation)-1"></a><a class="docs-heading-anchor-permalink" href="#Controlling-Gradient-Calculations-(Automatic-Differentiation)" title="Permalink"></a></h2><p>Notice that both of the above methods were derivative-free methods, and thus no gradients were required to do the optimization. However, in many cases first order optimization (i.e. using gradients) is much more efficient. Defining gradients can be done in two ways. One way is to manually provide a gradient definition in the <code>OptimizationFunction</code> constructor. However, the more convenient way to obtain gradients is to provide an AD backend type. </p><p>For example, let&#39;s now use the OptimizationOptimJL <code>BFGS</code> method to solve the same problem. We will import the forward-mode automatic differentiation library (<code>using ForwardDiff</code>) and then specify in the <code>OptimizationFunction</code> to automatically construct the derivative functions using ForwardDiff.jl. This looks like:</p><pre><code class="language-julia hljs">using ForwardDiff
optf = OptimizationFunction(rosenbrock, Optimization.AutoForwardDiff())
prob = OptimizationProblem(optf, u0, p)
sol = solve(prob,BFGS())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">u: 2-element Vector{Float64}:
 0.0
 0.0</code></pre><p>We can inspect the <code>original</code> to see the statistics on the number of steps  required and gradients computed:</p><pre><code class="language-julia hljs">sol.original</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"> * Status: success

 * Candidate solution
    Final objective value:     0.000000e+00

 * Found with
    Algorithm:     BFGS

 * Convergence measures
    |x - x&#39;|               = 0.00e+00 ≤ 0.0e+00
    |x - x&#39;|/|x&#39;|          = NaN ≰ 0.0e+00
    |f(x) - f(x&#39;)|         = NaN ≰ 0.0e+00
    |f(x) - f(x&#39;)|/|f(x&#39;)| = NaN ≰ 0.0e+00
    |g(x)|                 = 0.00e+00 ≤ 1.0e-08

 * Work counters
    Seconds run:   0  (vs limit Inf)
    Iterations:    0
    f(x) calls:    1
    ∇f(x) calls:   1
</code></pre><p>Sure enough, it&#39;s a lot less than the derivative-free methods!</p><p>However, the compute cost of forward-mode automatic differentiation scales via the number of inputs, and thus as our optimization problem grows large it slow down. To counteract this, for larger optimization problems (&gt;100 state variables) one normally would want to use reverse-mode automatic differentiation. One common choice for reverse-mode automatic differentiation is Zygote.jl. We can demonstrate this via:</p><pre><code class="language-julia hljs">using Zygote
optf = OptimizationFunction(rosenbrock, Optimization.AutoZygote())
prob = OptimizationProblem(optf, u0, p)
sol = solve(prob,BFGS())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">u: 2-element Vector{Float64}:
 0.0
 0.0</code></pre><h2 id="Setting-Box-Constraints"><a class="docs-heading-anchor" href="#Setting-Box-Constraints">Setting Box Constraints</a><a id="Setting-Box-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-Box-Constraints" title="Permalink"></a></h2><p>In many cases one knows the potential bounds on the solution values. In Optimization.jl, these can be supplied as the <code>lb</code> and <code>ub</code> arguments for the lower bounds and upper bounds respectively, supplying a vector of values with one per state variable. Let&#39;s now do our gradient-based optimization with box constraints by rebuilding the OptimizationProblem:</p><pre><code class="language-julia hljs">prob = OptimizationProblem(optf, u0, p, lb = [-1.0,-1.0], ub = [1.0,1.0])
sol = solve(prob,BFGS())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">u: 2-element Vector{Float64}:
 0.0
 0.0</code></pre><p>For more information on handling constraints, in particular equality and inequality constraints, take a look at the <a href="../constraints/#constraints">constraints tutorial</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Optimization.jl: A Unified Optimization Package</a><a class="docs-footer-nextpage" href="../rosenbrock/">Solving the Rosenbrock Problem in &gt;10 Ways »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Monday 20 June 2022 11:44">Monday 20 June 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
